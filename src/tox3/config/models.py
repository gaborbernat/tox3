"""configuration objects

these are a join of user provided inputs:
- cli
- environment variable
- tox config file
and generated by the running of these tool (referred to as state).
"""
import argparse
import re
from pathlib import Path
from typing import List, Optional, Dict

from .project import FileConf, BuildSystem
from .util import Substitute


class CoreToxConfig(Substitute):

    def __init__(self,
                 options: argparse.Namespace,
                 build_system: BuildSystem,
                 file: FileConf) -> None:
        self._options: argparse.Namespace = options
        self._file: FileConf = file
        self._build_system: BuildSystem = build_system

    @property
    def root_dir(self) -> Path:
        return self._options.__getattribute__('root_dir')

    @property
    def work_dir(self) -> Path:
        return self.root_dir / '.tox3'

    @property
    def build_requires(self) -> List[str]:
        return self._build_system.requires

    @property
    def build_backend_full(self) -> str:
        return self._build_system.backend.replace(':', '.')

    @property
    def build_backend(self) -> str:
        return self._build_system.backend

    @property
    def build_backend_base(self) -> str:
        at = self.build_backend.find(':')
        if at == -1:
            at = len(self.build_backend)
        return self.build_backend[:at]


class ToxConfig(CoreToxConfig):

    def __init__(self, options, build_system: BuildSystem, file):
        def _raw_env(env_name):
            base = {k: v for k, v in self._file['env'].items() if not isinstance(v, dict)}
            if env_name in self._file['env']:
                base.update(self._file['env'][env_name])
            return base

        self.build = BuildEnvConfig(options, build_system, _raw_env(BuildEnvConfig.NAME), BuildEnvConfig.NAME)
        self._envs: Dict[str, RunEnvConfig] = {k: RunEnvConfig(options, build_system, _raw_env(k), k) for k in
                                               self.envs}
        super().__init__(options, build_system, file)

    @property
    def envs(self):
        return self._file['envlist']

    @property
    def run_environments(self):
        environments = self._options.__getattribute__('environments')
        return environments if environments else self.envs

    def env(self, env_name: str) -> 'RunEnvConfig':
        return self._envs[env_name]


class EnvConfig(CoreToxConfig):
    def __init__(self,
                 _options: argparse.Namespace,
                 build_system: BuildSystem,
                 file: FileConf,
                 name: str):
        super().__init__(_options, build_system, file)
        self.name = name

    @property
    def python(self) -> str:
        key = 'basepython'
        if key in self._file:
            return self._file[key]
        match = re.match(r'py(\d)(\d)', self.name)
        if match:
            return 'python{}.{}'.format(match.group(1), match.group(2))
        raise ValueError('no base python for {}'.format(self.name))

    @property
    def recreate(self) -> bool:
        return self._options.__getattribute__('recreate')

    @property
    def build_wheel(self) -> bool:
        return self._file.get('build_wheel', True)

    @property
    def build_type(self) -> str:
        return 'wheel' if self.build_wheel else 'sdist'


class BuildEnvConfig(EnvConfig):
    NAME: str = '_build'
    _built_package: Optional[Path] = None
    _for_build_requires: List[str] = []

    @property
    def built_package(self) -> Optional[Path]:
        return self._built_package

    @built_package.setter
    def built_package(self, value: Path):
        self._built_package = value

    @property
    def for_build_requires(self) -> List[str]:
        return self._for_build_requires

    @for_build_requires.setter
    def for_build_requires(self, value: List[str]):
        self._built_package = value


class RunEnvConfig(EnvConfig):

    @property
    def commands(self) -> List[str]:
        return self._file['commands']

    @property
    def extras(self) -> List[str]:
        return self._file.get('extras', [])

    @property
    def description(self) -> Optional[str]:
        return self._file.get('description')
