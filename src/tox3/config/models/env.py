import argparse
import re
from pathlib import Path
from typing import Optional, cast

from tox3.venv import VEnv

from .core import CoreToxConfig
from ..project import BuildSystem, FileConf


class EnvConfig(CoreToxConfig):
    def __init__(self,
                 _options: argparse.Namespace,
                 build_system: BuildSystem,
                 file: FileConf,
                 work_dir: Path,
                 name: str) -> None:
        super().__init__(_options, build_system, file, work_dir)
        self.name = name
        # generated by running
        self.venv: Optional[VEnv] = None  # virtualenv generation

    @property
    def python(self) -> str:
        key = 'basepython'
        if key in self._file:
            return cast(str, self._file[key])
        match = re.match(r'py(\d)(\d+)', self.name)
        if match:
            return 'python{}.{}'.format(match.group(1), match.group(2))
        raise ValueError('no base python for {}'.format(self.name))

    @property
    def recreate(self) -> bool:
        return cast(bool, self._options.__getattribute__('recreate'))

    @property
    def envsitepackagesdir(self) -> Path:
        self.ensure_venv_ready()
        return cast(VEnv, self.venv).params.site_package

    @property
    def envbindir(self) -> Path:
        self.ensure_venv_ready()
        return cast(VEnv, self.venv).params.bin_path

    def ensure_venv_ready(self) -> None:
        if self.venv is None:
            raise TypeError('virtual environment not yet created')

    @property
    def envdir(self) -> Path:
        self.ensure_venv_ready()
        return cast(VEnv, self.venv).params.root_dir

    @property
    def envpython(self) -> Path:
        self.ensure_venv_ready()
        return cast(VEnv, self.venv).params.executable

    @property
    def envname(self) -> str:
        return self.name

    @property
    def install_command(self) -> str:
        return self._file.get('install_command', 'pip install -U')
